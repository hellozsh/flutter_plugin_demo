# 如何写一个与原生沟通的插件

## 1.构建一个插件

1. 构建一个插件

   ```javascript
   // xxx为那个你喜欢的唯一名
   // -a指定安卓开发语言,默认Swift
   // -i指定ios开发语言,默认Kotlin
   flutter create --template=plugin --platforms=android,ios -i objc -a java xxx
   ```

2. ![插件目录](./插件目录.png)

## 2.概念





## 3.使用

### 1. flutter调用原生方法(带/不带参数 有/无返回值)

####    flutter端

1. 定义MethodChannel, 一个插件可以有多个MethodChannel,为了唯一性,建议channel名字带有前缀

2. flutter端代码--在lib文件夹下写

   1. 删掉zsh_demo.dart里的代码,新建立demo_channel.dart专门定义channel,新建立function.dart文件专门负责交互方法

   2. 文件结构如图

       ![flutter_文件目录结构](./flutter_文件目录结构.png)

   3. zsh_demo.dart只导入资源文件,代码如上;

   4. demo_channel.dart专门定义cahnnel, 如下: 

      ![flutter_1_demo_channel](./flutter_1_demo_channel.png)

   5. demo_function.dart专门写方法,如下:

       ![flutter_1_demo_function](./flutter_1_demo_function.png)

   6. 以上,flutter端完事

   7. 写ios和安卓端代码之前,先到example下依次执行flutter build ios, 和 flutter build apk, 这样才能打开带插件又能运行demo的代码

#### ios端

1. 目录ios右键------> flutter ------> Open ios module in Xcode

2. Runner里的只是demo代码,写插件的代码在Pods下,如图:

   ![ios_1_目录](./ios_1_目录.png)

3. 注册channel,注册后,flutter发送给原生的方法会走代理handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result

4. ![ios_1_代码](./ios_1_代码.png)

#### 安卓端

1. 目录android右键------> flutter ------> Open Android module in Android Studio
2. ![android_1_代码](./android_1_代码.png)

### 2. 原生调用flutter方法

原生调用flutter方法和上面相同,只是invokeMethod由原生调用, 监听由flutter监听

#### flutter端

![flutter_2](./flutter_2.png)

#### ios端和安卓端

```
/// 安卓方
channel.invokeMethod("nativeToFlutter", "安卓 参数");

/// ios方
[self.channel invokeMethod:@"nativeToFlutter" arguments:@"ios 参数"];
```

#### 配合stream使用

1. 假设有个需求, 我们的插件收到了参数,处理后,要把值显示在UI上,怎么处理

2. 方法: 借助stream流实现, ios和安卓端都不需要修改, 把flutter方的代码修改成如下

   ![flutter_2_stream](./flutter_2_stream.png)

3. 使用该插件的项目,就可以利用streamBuildr来实现监听结果了

   ![flutter_2_example](./flutter_2_example.png)

### 3. flutter显示原生view

#### flutter端

1. flutter端,和ios的交互是利用的UiKitView, 和安卓是利用的AndroidView

2. 根据不同平台,使用不同的widget来加载, viewType是不同端之间沟通的唯一标识,需要唯一性和一致性

   ##### 1.demo_channel新添常量viewType的唯一标识字符串

   ```javascript
   const String LABEL_VIEW = '$NAMESPACE/labelView';
   ```

   ##### 2.定义接口

   ```
   
   part of zsh_demo;
   
   abstract class PlatformView {
   
     Widget build({
       BuildContext context,
     });
   }
   ```

   ##### 3.ios平台的view

   ```javascript
   part of zsh_demo;
   
   class IosLabelView implements PlatformView {
   
     @override
     Widget build({BuildContext context}) {
   
       return UiKitView(
         viewType: LABEL_VIEW,
       );
     }
   }
   ```

   ##### 4.安卓平台的view

   ```javascript
   part of zsh_demo;
   
   class AndroidLabelView implements PlatformView {
   
     @override
     Widget build({BuildContext context}) {
   
       return AndroidView(
         viewType: LABEL_VIEW,
       );
     }
   }
   ```

#####     5.构建外界使用的widget

```javascript
part of zsh_demo;



// ignore: must_be_immutable
class LabelWidget extends StatelessWidget {

  /// 执行build构建widget
  @override
  Widget build(BuildContext context) {

    return platform.build(context: context);
  }

  PlatformView _platform;

  set platform(PlatformView platform) {
    _platform = platform;
  }

  /// 根据不同平台创建不同的view
  PlatformView get platform {
    if (_platform == null) {
      switch (defaultTargetPlatform) {
        case TargetPlatform.android:
          _platform = AndroidLabelView();
          break;
        case TargetPlatform.iOS:
          _platform = IosLabelView();
          break;
        default:
          throw UnsupportedError(
              "Trying to use the default webview implementation for $defaultTargetPlatform but there isn't a default one");
      }
    }
    return _platform;
  }
}
```

#### ios端

1. 运行以上flutter代码,会将viewType为 LABEL_VIEW的消息发到ios端,ios实现FlutterPlatformViewFactory接口方法既可

   1. .h文件

      ![ios_3_h](./ios_3_h.png)

   2.  .m文件

      ![ios_3_m_1](./ios_3_m_1.png)

![ios_3_m_2](./ios_3_m_2.png)

3. 注册, 在registerWithRegistrar:方法里注册Factory

   ```
    LabelViewFactory* webviewFactory =
            [[LabelViewFactory alloc] initWithMessenger:registrar.messenger];
       
    NSString *viewType = [NSString stringWithFormat:@"%@/labelView",NAMESPACE];
    [registrar registerViewFactory:webviewFactory withId:viewType];
   ```

#### 安卓端



#### flutter让原生view更新数据



### 4. 原生显示flutter widget

### 5.flutter监听原生数据流

#### 和invote区别

#### stream的几种

## 4.更优的数据交互:Protoful